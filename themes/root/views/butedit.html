<!--

  thisProperty
  editElement
  inlineEdition
  thisAttribute
  image=normal / code (for code edition)
  autoeditFunc
  autoeditParams
  
  it uses data-id=butedit y data-id=admnbuts at containers for buttons to hidde buttons meanwhile editing
-->
<div>
  <button type="button" class="butedit" style="display:none" data-id="normbut">
    <div class="editimage"></div>
    <script>
      if (window.getComputedStyle(thisElement).backgroundImage) {
        const {setSizeFromStyle}=await import('./' + CLIENT_MODULES_PATH + 'frontutils.js');
        setSizeFromStyle(thisElement);
      }
    </script>
  </button>
  <button type="button" class="buteditcode" style="display:none" data-id="codebut">
    <div class="editcodeimage"></div>
    <script>
      if (window.getComputedStyle(thisElement).backgroundImage) {
        const {setSizeFromStyle}=await import('./' + CLIENT_MODULES_PATH + 'frontutils.js');
        setSizeFromStyle(thisElement);
      }
    </script>
  </button>
</div>
<script>
  //short names
  let thisProperty=thisParams.thisProperty;
  let editElement=thisParams.editElement;
  let thisAttribute=thisParams.thisAttribute;

  let buttonElement=thisElement.querySelector('button[data-id=normbut]');
  if (thisParams.image=='code') {
    buttonElement=thisElement.querySelector('button[data-id=codebut]');
  }
  buttonElement.style.display='block';

  if (!thisProperty) {
    // git first property different from id
    let keys=Object.keys(thisNode.props);
    if (thisNode.parentNode && thisNode.parentNode.childtablekeys && thisNode.parentNode.childtablekeys.length>0) {
      keys=thisNode.parentNode.childtablekeys;
    }
    thisProperty = keys.find(key => key!='id');
  }
  if (!thisAttribute) {
    if (editElement.tagName=='INPUT' || editElement.tagName=='TEXTAREA') thisAttribute="value";
    else thisAttribute="textContent";
  }
  if (typeof thisParams.autoeditFunc=="function") buttonElement.onclick=function() {
    thisNode.addEventListener("finishAutoEdit", changeProperty, "autoedit");
    thisParams.autoeditFunc.call(thisNode, thisParams.autoeditParams);
  }
  else {
    function setVisibilityButtons(vis){
      function changeVisibility(buts, vis){
        for (const but of buts) {
          but.style.visibility=vis;
        }
      }
      changeVisibility(editElement.parentElement.querySelectorAll("[data-id=butedit]"), vis);
      changeVisibility(editElement.parentElement.querySelectorAll("[data-id=admnbuts]"), vis);
    }
    const activeEdition=function(){
      editElement.setAttribute("contenteditable","true");
      editElement.classList.remove("contenteditableactive");
      if ((editElement.tagName=="INPUT" || editElement.tagName=="TEXTAREA") && editElement.disabled==true) editElement.disabled=false;
      if ((editElement.tagName=="INPUT" || editElement.tagName=="TEXTAREA") && editElement.type=='hidden') editElement.type='text';
      // Hide admin buttons when write
      setVisibilityButtons("hidden");
      editElement.focus();
    };
    const unActiveEdition=function() {
      editElement.setAttribute("contenteditable","false");
      editElement.classList.remove("contenteditableactive");
      if ((editElement.tagName=="INPUT" || editElement.tagName=="TEXTAREA") && editElement.disabled===false) editElement.disabled=true;
      //Set visible edit and admin buttons
      setVisibilityButtons("visible");
    };
    const listenerIntroKey=function(e) {
      if (e.keyCode == 13) {
        e.preventDefault(); //Not to submit but I think it doesn't work
        editElement.removeEventListener("blur", listenerBlur); //AFter keydown then blur happens
        //finishEdition
        changeProperty()
        .then(()=>{
          unActiveEdition();
          editElement.removeEventListener('keydown', listenerIntroKey);
        });
      }
    };
    const listenerBlur=function(e) {
      //finishEdition
      changeProperty()
      .then(()=>{
        unActiveEdition();
        editElement.removeEventListener("blur", listenerBlur);
      });
    };    
    buttonElement.addEventListener('click', (event) => {
      event.preventDefault();
      activeEdition();
      if (!(thisParams.inlineEdition===false)) {
        //disable Intro keyCode for new Line and enable it for submith
        editElement.addEventListener('keydown', listenerIntroKey);
      }
      editElement.addEventListener("blur", listenerBlur);
    });
  }
  async function changeProperty(){
    let elementValue=null;
    if (editElement.getAttribute(thisAttribute)!==null && thisAttribute!="value") elementValue=editElement.getAttribute(thisAttribute);
    // src, href we want the relative address (attribute rather than property) but for value we want the actual value (proerty rather than attribute
    else elementValue=editElement[thisAttribute];
    if (thisNode.props[thisProperty] != elementValue) { //just when content change and not void
      const response = await thisNode.request("edit my props", {props:{[thisProperty]: elementValue}})
      if (response!=1) return false;
      thisNode.props[thisProperty]=elementValue;
    }
    thisNode.dispatchEvent("changeProperty", thisProperty);
  };
</script>